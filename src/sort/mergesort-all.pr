:- initialize.

:- tex_file($(lib)/mergesort/mergesort).
:- thm_file($(lib)/mergesort/mergesort).

:- needs_gr($(lib)/sort/mergesort).

:- needs_thm($(lib)/list/list).
:- needs_gr($(lib)/list/list).
:- needs_thm($(lib)/nat/nat).
:- needs_gr($(lib)/nat/nat).
:- needs_thm($(lib)/permutation/permutation).
:- needs_gr($(lib)/permutation/permutation).

:- axiom(app:associative, all[l1,l2,l3]:succeeds list(?l1)&succeeds list(?l2)=> ?l1** ?l2** ?l3= ?l1**(?l2** ?l3)).
:- axiom(app:cons, all[x,l1,l2]:succeeds list(?l1)=>[?x|?l1]** ?l2=[?x|?l1** ?l2]).
:- axiom(app:ground:1, all[l1,l2]:succeeds list(?l1)&gr(?l1)&gr(?l2)=>gr(?l1** ?l2)).
:- axiom(app:ground:2, all[l1,l2]:succeeds list(?l1)&gr(?l1** ?l2)=>gr(?l1)&gr(?l2)).
:- axiom(app:lh, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)=>lh(?l1** ?l2)=lh(?l1)@+lh(?l2)).
:- axiom(app:lh:leq:first, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)=>succeeds lh(?l1)@=<lh(?l1** ?l2)).
:- axiom(app:lh:leq:second, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)=>succeeds lh(?l2)@=<lh(?l1** ?l2)).
:- axiom(app:member:1, all[x,l1,l2]:succeeds member(?x,?l1)&succeeds list(?l1)=>succeeds member(?x,?l1** ?l2)).
:- axiom(app:member:2, all[x,l1,l2]:succeeds member(?x,?l2)&succeeds list(?l1)=>succeeds member(?x,?l1** ?l2)).
:- axiom(app:member:3, all[x,l1,l2]:succeeds list(?l1)&succeeds member(?x,?l1** ?l2)=>succeeds member(?x,?l1)\/succeeds member(?x,?l2)).
:- axiom(app:nil, all l:[]** ?l= ?l).
:- axiom(app:nil, all l:succeeds list(?l)=> ?l**[]= ?l).
:- axiom(app:types:1, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)=>succeeds list(?l1** ?l2)).
:- axiom(app:types:2, all[l1,l2]:succeeds list(?l1)&succeeds list(?l1** ?l2)=>succeeds list(?l2)).
:- axiom(app:uniqueness:1, all[l1,l2,l3]:succeeds list(?l1)&succeeds list(?l2)&succeeds list(?l3)& ?l1** ?l3= ?l2** ?l3=> ?l1= ?l2).
:- axiom(append:cons:different, all[x,l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds list(?l3)=> ?l2<>[?x|?l3]).
:- axiom(append:equal:nil, all[l1,l2]:succeeds append(?l1,?l2,?l2)&succeeds list(?l2)=> ?l1=[]).
:- axiom(append:existence, all[l1,l2]:succeeds list(?l1)=>(ex l3:succeeds append(?l1,?l2,?l3))).
:- axiom(append:ground:1, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&gr(?l1)&gr(?l2)=>gr(?l3)).
:- axiom(append:ground:2, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&gr(?l3)=>gr(?l1)&gr(?l2)).
:- axiom(append:lh, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds list(?l3)=>lh(?l1)@+lh(?l2)=lh(?l3)).
:- axiom(append:lh:leq:first, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds list(?l3)=>succeeds lh(?l1)@=<lh(?l3)).
:- axiom(append:lh:leq:second, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds list(?l3)=>succeeds lh(?l2)@=<lh(?l3)).
:- axiom(append:member, all[x,l1,l2,l3]:succeeds append(?l1,[?x|?l2],?l3)=>succeeds member(?x,?l3)).
:- axiom(append:member:1, all[x,l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds member(?x,?l1)=>succeeds member(?x,?l3)).
:- axiom(append:member:2, all[x,l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds member(?x,?l2)=>succeeds member(?x,?l3)).
:- axiom(append:member:3, all[x,l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds member(?x,?l3)=>succeeds member(?x,?l1)\/succeeds member(?x,?l2)).
:- axiom(append:termination:1, all[l1,l2,l3]:succeeds list(?l1)=>terminates append(?l1,?l2,?l3)).
:- axiom(append:termination:2, all[l1,l2,l3]:succeeds list(?l3)=>terminates append(?l1,?l2,?l3)).
:- axiom(append:types:1, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)=>succeeds list(?l1)).
:- axiom(append:types:2, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds list(?l2)=>succeeds list(?l3)).
:- axiom(append:types:3, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds list(?l3)=>succeeds list(?l2)).
:- axiom(append:types:4, all[l1,l2,l3]:succeeds append(?l1,?l2,?l3)&succeeds list(?l3)=>succeeds list(?l1)&succeeds list(?l2)).
:- axiom(append:uniqueness, all[l1,l2,l3,l4]:succeeds append(?l1,?l2,?l3)&succeeds append(?l1,?l2,?l4)=> ?l3= ?l4).
:- axiom(append:uniqueness:1, all[l1,l2,l3,l4]:succeeds append(?l1,?l2,?l3)&succeeds append(?l4,?l2,?l3)&succeeds list(?l3)=> ?l1= ?l4).
:- axiom(append:uniqueness:2, all[l1,l2,l3,l4]:succeeds append(?l1,?l2,?l3)&succeeds append(?l1,?l4,?l3)=> ?l2= ?l4).
:- axiom(delete:app:1, all[x,l1,l2]:succeeds list(?l1)=>succeeds delete(?x,?l1**[?x|?l2],?l1** ?l2)).
:- axiom(delete:app:2, all[x,l1,l2]:succeeds delete(?x,?l1,?l2)=>(ex[l3,l4]:succeeds list(?l3)& ?l1= ?l3**[?x|?l4]& ?l2= ?l3** ?l4)).
:- axiom(delete:ground, all[x,l1,l2]:succeeds delete(?x,?l1,?l2)&gr(?l1)=>gr(?x)&gr(?l2)).
:- axiom(delete:length, all[x,l1,l2]:succeeds delete(?x,?l1,?l2)&succeeds list(?l1)=>lh(?l1)=s(lh(?l2))).
:- axiom(delete:member:1, all[x,y,l1,l2]:succeeds delete(?x,?l1,?l2)&succeeds member(?y,?l1)=>succeeds member(?y,?l2)\/ ?y= ?x).
:- axiom(delete:member:2, all[x,l1,l2]:succeeds delete(?x,?l1,?l2)=>succeeds member(?x,?l1)).
:- axiom(delete:member:3, all[x,y,l1,l2]:succeeds delete(?x,?l1,?l2)&succeeds member(?y,?l2)=>succeeds member(?y,?l1)).
:- axiom(delete:member:different, all[x,y,l1,l2]:succeeds delete(?x,?l1,?l2)&succeeds member(?y,?l1)& ?x<> ?y=>succeeds member(?y,?l2)).
:- axiom(delete:member:existence, all[x,l1]:succeeds member(?x,?l1)=>(ex l2:succeeds delete(?x,?l1,?l2))).
:- axiom(delete:nat_list, all[x,l1,l2]:succeeds delete(?x,?l1,?l2)&succeeds nat_list(?l1)=>succeeds nat(?x)&succeeds nat_list(?l2)).
:- axiom(delete:occ:diff, all[x,y,l1,l2]:succeeds list(?l1)&succeeds delete(?x,?l1,?l2)& ?x<> ?y=>occ(?y,?l1)=occ(?y,?l2)).
:- axiom(delete:occ:eq, all[x,l1,l2]:succeeds list(?l1)&succeeds delete(?x,?l1,?l2)=>occ(?x,?l1)=s(occ(?x,?l2))).
:- axiom(delete:termination:1, all[x,l1,l2]:succeeds list(?l1)=>terminates delete(?x,?l1,?l2)).
:- axiom(delete:termination:2, all[x,l1,l2]:succeeds list(?l2)=>terminates delete(?x,?l1,?l2)).
:- axiom(delete:types:1, all[x,l1,l2]:succeeds delete(?x,?l1,?l2)&succeeds list(?l1)=>succeeds list(?l2)).
:- axiom(delete:types:2, all[x,l1,l2]:succeeds delete(?x,?l1,?l2)&succeeds list(?l2)=>succeeds list(?l1)).
:- axiom(length:existence, all l:succeeds list(?l)=>(ex n:succeeds length(?l,?n))).
:- axiom(length:ground, all[l,n]:succeeds length(?l,?n)=>gr(?n)).
:- axiom(length:termination, all[l,n]:succeeds list(?l)=>terminates length(?l,?n)).
:- axiom(length:types, all[l,n]:succeeds length(?l,?n)=>succeeds list(?l)&succeeds nat(?n)).
:- axiom(length:uniqueness, all[l,m,n]:succeeds length(?l,?m)&succeeds length(?l,?n)=> ?m= ?n).
:- axiom(leq:antisymmetric, all[x,y]:succeeds?x@=< ?y&succeeds?y@=< ?x=> ?x= ?y).
:- axiom(leq:failure, all[x,y]:succeeds nat(?x)&succeeds nat(?y)&fails?x@=< ?y=>succeeds?y@=< ?x).
:- axiom(leq:less, all[x,y]:succeeds?x@=< ?y&succeeds nat(?y)=>succeeds?x@< ?y\/ ?x= ?y).
:- axiom(leq:less:transitive, all[x,y,z]:succeeds?x@=< ?y&succeeds?y@< ?z=>succeeds?x@< ?z).
:- axiom(leq:one:failure, all x:succeeds nat(?x)=>fails s(?x)@=< ?x).
:- axiom(leq:one:success, all x:succeeds nat(?x)=>succeeds?x@=<s(?x)).
:- axiom(leq:plus, all[x,y]:succeeds?x@=< ?y=>(ex z: ?x@+ ?z= ?y)).
:- axiom(leq:plus, all[x,y]:succeeds?x@=< ?y=>(ex z:succeeds plus(?x,?z,?y))).
:- axiom(leq:plus:first, all[x,y,z]:succeeds?x@=< ?y&succeeds nat(?y)&succeeds nat(?z)=>succeeds?x@+ ?z@=< ?y@+ ?z).
:- axiom(leq:plus:first, all[x,y]:succeeds nat(?x)=>succeeds?x@=< ?x@+ ?y).
:- axiom(leq:plus:inverse, all[x,y,z]:succeeds nat(?x)&succeeds?x@+ ?y@=< ?x@+ ?z=>succeeds?y@=< ?z).
:- axiom(leq:plus:second, all[x,y,z]:succeeds nat(?x)&succeeds?y@=< ?z=>succeeds?x@+ ?y@=< ?x@+ ?z).
:- axiom(leq:plus:second, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>succeeds?y@=< ?x@+ ?y).
:- axiom(leq:reflexive, all x:succeeds nat(?x)=>succeeds?x@=< ?x).
:- axiom(leq:termination:1, all[x,y]:succeeds nat(?x)=>terminates?x@=< ?y).
:- axiom(leq:termination:2, all[x,y]:succeeds nat(?y)=>terminates?x@=< ?y).
:- axiom(leq:times:inverse, all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)&succeeds nat(?z)&succeeds s(?x)@* ?y@=<s(?x)@* ?z=>succeeds?y@=< ?z).
:- axiom(leq:totality, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>succeeds?x@=< ?y\/succeeds?y@=< ?x).
:- axiom(leq:transitive, all[x,y,z]:succeeds?x@=< ?y&succeeds?y@=< ?z=>succeeds?x@=< ?z).
:- axiom(leq:types, all[x,y]:succeeds?x@=< ?y=>succeeds nat(?x)).
:- axiom(less:axiom:successor, all[x,y]:succeeds nat(?y)&succeeds?x@<s(?y)=>succeeds?x@< ?y\/ ?x= ?y).
:- axiom(less:different:zero, all x:succeeds nat(?x)& ?x<>0=>succeeds 0@< ?x).
:- axiom(less:failure, all x:succeeds nat(?x)=>fails?x@< ?x).
:- axiom(less:leq, all[x,y]:succeeds?x@< ?y=>succeeds?x@=< ?y).
:- axiom(less:leq:total, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>succeeds?x@< ?y\/succeeds?y@=< ?x).
:- axiom(less:leq:transitive, all[x,y,z]:succeeds?x@< ?y&succeeds?y@=< ?z=>succeeds?x@< ?z).
:- axiom(less:one, all x:succeeds nat(?x)=>succeeds?x@<s(?x)).
:- axiom(less:plus, all[x,y]:succeeds?x@< ?y=>(ex z: ?x@+s(?z)= ?y)).
:- axiom(less:plus, all[x,y]:succeeds?x@< ?y=>(ex z:succeeds plus(?x,s(?z),?y))).
:- axiom(less:plus:first, all[x,y,z]:succeeds?x@< ?y&succeeds nat(?y)&succeeds nat(?z)=>succeeds?x@+ ?z@< ?y@+ ?z).
:- axiom(less:plus:first, all[x,y]:succeeds 0@< ?y&succeeds nat(?x)&succeeds nat(?y)=>succeeds?x@< ?y@+ ?x).
:- axiom(less:plus:inverse, all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)&succeeds nat(?z)&succeeds?x@+ ?z@< ?y@+ ?z=>succeeds?x@< ?y).
:- axiom(less:plus:inverse, all[x,y,z]:succeeds nat(?x)&succeeds?x@+ ?y@< ?x@+ ?z=>succeeds?y@< ?z).
:- axiom(less:plus:second, all[x,y,z]:succeeds nat(?x)&succeeds?y@< ?z=>succeeds?x@+ ?y@< ?x@+ ?z).
:- axiom(less:plus:second, all[x,y]:succeeds nat(?x)=>succeeds?x@< ?x@+s(?y)).
:- axiom(less:strictness, all x:succeeds nat(?x)=> ~succeeds?x@< ?x).
:- axiom(less:successor, all[x,y]:succeeds?x@< ?y=>(ex z: ?y=s(?z))).
:- axiom(less:termination:1, all[x,y]:succeeds nat(?x)=>terminates?x@< ?y).
:- axiom(less:termination:2, all[x,y]:succeeds nat(?y)=>terminates?x@< ?y).
:- axiom(less:totality, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>succeeds?x@< ?y\/ ?x= ?y\/succeeds?y@< ?x).
:- axiom(less:transitive, all[x,y,z]:succeeds?x@< ?y&succeeds?y@< ?z=>succeeds?x@< ?z).
:- axiom(less:transitive:successor, all[x,y,z]:succeeds?x@< ?y&succeeds?y@<s(?z)=>succeeds?x@< ?z).
:- axiom(less:types, all[x,y]:succeeds?x@< ?y=>succeeds nat(?x)).
:- axiom(less:weakening, all[x,y]:succeeds?x@< ?y=>succeeds?x@<s(?y)).
:- axiom(lh:cons, all[x,l]:succeeds list(?l)=>lh([?x|?l])=s(lh(?l))).
:- axiom(lh:cons:first, all[x,l1,l2,n]:succeeds list(?l1)&succeeds list(?l2)&succeeds lh([?x|?l1])@+lh(?l2)@<s(?n)=>succeeds lh(?l1)@+lh(?l2)@< ?n).
:- axiom(lh:cons:leq, all[x,l]:succeeds list(?l)=>succeeds lh(?l)@=<lh([?x|?l])).
:- axiom(lh:cons:second, all[l1,y,l2,n]:succeeds list(?l1)&succeeds list(?l2)&succeeds lh(?l1)@+lh([?y|?l2])@<s(?n)=>succeeds lh(?l1)@+lh(?l2)@< ?n).
:- axiom(lh:nil, lh([])=0).
:- axiom(lh:successor, all[n,l1]:succeeds list(?l1)&lh(?l1)=s(?n)=>(ex[x,l2]: ?l1=[?x|?l2])).
:- axiom(lh:types, all l:succeeds list(?l)=>succeeds nat(lh(?l))).
:- axiom(lh:zero, all l:succeeds list(?l)&lh(?l)=0=> ?l=[]).
:- axiom(list:1, all x:succeeds list([?x])).
:- axiom(list:2, all[x,y]:succeeds list([?x,?y])).
:- axiom(list:3, all[x,y,z]:succeeds list([?x,?y,?z])).
:- axiom(list:cons, all[x,l]:succeeds list([?x|?l])=>succeeds list(?l)).
:- axiom(list:termination, all l:succeeds list(?l)=>terminates list(?l)).
:- axiom(member2:ground, all[x,l1,l2]:succeeds member2(?x,?l1,?l2)&gr(?l1)&gr(?l2)=>gr(?x)).
:- axiom(member2:termination, all[x,l1,l2]:succeeds list(?l1)&succeeds list(?l2)=>terminates member2(?x,?l1,?l2)).
:- axiom(member:append, all[x,l3]:succeeds member(?x,?l3)=>(ex[l1,l2]:succeeds append(?l1,[?x|?l2],?l3))).
:- axiom(member:cons, all[x,y,z,l]:succeeds member(?x,[?y|?l])& ?x<> ?y=>succeeds member(?x,?l)).
:- axiom(member:ground, all[x,l]:succeeds member(?x,?l)&gr(?l)=>gr(?x)).
:- axiom(member:occ:success, all[x,l]:succeeds list(?l)&succeeds member(?x,?l)=>(ex n:occ(?x,?l)=s(?n))).
:- axiom(member:termination, all[x,l]:succeeds list(?l)=>succeeds member(?x,?l)\/fails member(?x,?l)).
:- axiom(member:termination, all[x,l]:succeeds list(?l)=>terminates member(?x,?l)).
:- axiom(nat:ground, all x:succeeds nat(?x)=>gr(?x)).
:- axiom(nat:termination, all x:succeeds nat(?x)=>terminates nat(?x)).
:- axiom(nat_list:ground, all x:succeeds nat_list(?x)=>gr(?x)).
:- axiom(nat_list:list, all l:succeeds nat_list(?l)=>succeeds list(?l)).
:- axiom(nat_list:termination, all l:succeeds nat_list(?l)=>terminates nat_list(?l)).
:- axiom(not_same_occ:termination, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)&gr(?l1)&gr(?l2)=>terminates not_same_occ(?l1,?l2)).
:- axiom(occ:app, all[x,l1,l2]:succeeds list(?l1)&succeeds list(?l2)=>occ(?x,?l1** ?l2)=occ(?x,?l1)@+occ(?x,?l2)).
:- axiom(occ:cons:diff, all[x,y,l]:succeeds list(?l)& ?x<> ?y=>occ(?x,[?y|?l])=occ(?x,?l)).
:- axiom(occ:cons:eq, all[x,l]:succeeds list(?l)=>occ(?x,[?x|?l])=s(occ(?x,?l))).
:- axiom(occ:existence, all[x,l]:succeeds list(?l)=>(ex n:succeeds occ(?x,?l,?n))).
:- axiom(occ:ground, all[x,l,n]:succeeds occ(?x,?l,?n)=>gr(?n)).
:- axiom(occ:member, all[x,l]:succeeds list(?l)&fails member(?x,?l)=>occ(?x,?l)=0).
:- axiom(occ:member:success, all[x,l,n]:succeeds list(?l)&occ(?x,?l)=s(?n)=>succeeds member(?x,?l)).
:- axiom(occ:member:success, all[x,l,n]:succeeds list(?l)&succeeds occ(?x,?l,s(?n))=>succeeds member(?x,?l)).
:- axiom(occ:nil, all x:occ(?x,[])=0).
:- axiom(occ:permutation, all[l1,l2]:succeeds list(?l2)&succeeds list(?l1)&(all x:occ(?x,?l1)=occ(?x,?l2))=>succeeds permutation(?l1,?l2)).
:- axiom(occ:successor, all[x,l1,n]:succeeds list(?l1)&occ(?x,?l1)=s(?n)=>(ex l2:succeeds delete(?x,?l1,?l2))).
:- axiom(occ:termination, all[x,l,n]:succeeds list(?l)&gr(?l)&gr(?x)=>terminates occ(?x,?l,?n)).
:- axiom(occ:types, all[x,l,n]:succeeds occ(?x,?l,?n)=>succeeds list(?l)&succeeds nat(?n)).
:- axiom(occ:types, all[x,l]:succeeds list(?l)=>succeeds nat(occ(?x,?l))).
:- axiom(occ:uniqueness, all[x,l,m,n]:succeeds occ(?x,?l,?m)&succeeds occ(?x,?l,?n)=> ?m= ?n).
:- axiom(occ:zero, all l:succeeds list(?l)&(all x:occ(?x,?l)=0)=> ?l=[]).
:- axiom(permutation:app, all[l1,l2,l3,l4]:succeeds permutation(?l1,?l3)&succeeds permutation(?l2,?l4)=>succeeds permutation(?l1** ?l2,?l3** ?l4)).
:- axiom(permutation:app:commutative, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)=>succeeds permutation(?l1** ?l2,?l2** ?l1)).
:- axiom(permutation:completeness, all l2:succeeds list(?l2)=>(all l1:succeeds list(?l1)&(all x:occ(?x,?l1)=occ(?x,?l2))=>succeeds permutation(?l1,?l2))).
:- axiom(permutation:completeness, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)&succeeds same_occ(?l1,?l2)=>succeeds permutation(?l1,?l2)).
:- axiom(permutation:cons, all[x,l1,l2]:succeeds permutation([?x|?l1],[?x|?l2])=>succeeds permutation(?l1,?l2)).
:- axiom(permutation:ground, all[l1,l2]:succeeds permutation(?l1,?l2)&gr(?l1)=>gr(?l2)).
:- axiom(permutation:length, all[l1,l2]:succeeds permutation(?l1,?l2)=>lh(?l1)=lh(?l2)).
:- axiom(permutation:member, all[x,l1,l2]:succeeds permutation(?l1,?l2)&succeeds member(?x,?l1)=>succeeds member(?x,?l2)).
:- axiom(permutation:nat_list, all[l1,l2]:succeeds permutation(?l1,?l2)&succeeds nat_list(?l1)=>succeeds nat_list(?l2)).
:- axiom(permutation:nil, all l:succeeds permutation([],?l)=> ?l=[]).
:- axiom(permutation:occ, all[l1,l2]:succeeds permutation(?l1,?l2)=>(all x:occ(?x,?l1)=occ(?x,?l2))).
:- axiom(permutation:reflexive, all l:succeeds list(?l)=>succeeds permutation(?l,?l)).
:- axiom(permutation:soundness, all[l1,l2]:succeeds permutation(?l1,?l2)&gr(?l1)&gr(?l2)=>succeeds same_occ(?l1,?l2)).
:- axiom(permutation:symmetric, all[l1,l2]:succeeds permutation(?l1,?l2)=>succeeds permutation(?l2,?l1)).
:- axiom(permutation:termination, all[l1,l2]:succeeds list(?l1)=>terminates permutation(?l1,?l2)).
:- axiom(permutation:termination, all[n,l1,l2]:succeeds nat(?n)&succeeds list(?l1)&lh(?l1)= ?n=>terminates permutation(?l1,?l2)).
:- axiom(permutation:transitive, all[l1,l2,l3]:succeeds permutation(?l1,?l2)&succeeds permutation(?l2,?l3)=>succeeds permutation(?l1,?l3)).
:- axiom(permutation:types, all[l1,l2]:succeeds permutation(?l1,?l2)=>succeeds list(?l1)&succeeds list(?l2)).
:- axiom(plus:associative, all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)&succeeds nat(?z)=> ?x@+ ?y@+ ?z= ?x@+(?y@+ ?z)).
:- axiom(plus:commutative, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=> ?x@+ ?y= ?y@+ ?x).
:- axiom(plus:existence, all[x,y]:succeeds nat(?x)=>(ex z:succeeds plus(?x,?y,?z))).
:- axiom(plus:ground:1, all[x,y,z]:succeeds plus(?x,?y,?z)=>gr(?x)).
:- axiom(plus:ground:2, all[x,y,z]:succeeds plus(?x,?y,?z)&gr(?y)=>gr(?z)).
:- axiom(plus:ground:3, all[x,y,z]:succeeds plus(?x,?y,?z)&gr(?z)=>gr(?y)).
:- axiom(plus:injective:first, all[x1,x2,y]:succeeds nat(?x1)&succeeds nat(?x2)&succeeds nat(?y)& ?x1@+ ?y= ?x2@+ ?y=> ?x1= ?x2).
:- axiom(plus:injective:second, all[x,y,z]:succeeds nat(?x)& ?x@+ ?y= ?x@+ ?z=> ?y= ?z).
:- axiom(plus:leq:leq, all[x1,x2,y1,y2]:succeeds?x1@=< ?y1&succeeds?x2@=< ?y2&succeeds nat(?y1)=>succeeds?x1@+ ?x2@=< ?y1@+ ?y2).
:- axiom(plus:leq:less, all[x1,x2,y1,y2]:succeeds?x1@=< ?y1&succeeds?x2@< ?y2&succeeds nat(?y1)=>succeeds?x1@+ ?x2@< ?y1@+ ?y2).
:- axiom(plus:less:leq, all[x1,x2,y1,y2]:succeeds?x1@< ?y1&succeeds?x2@=< ?y2&succeeds nat(?y1)=>succeeds?x1@+ ?x2@< ?y1@+ ?y2).
:- axiom(plus:less:less, all[x1,x2,y1,y2]:succeeds?x1@< ?y1&succeeds?x2@< ?y2&succeeds nat(?y1)=>succeeds?x1@+ ?x2@< ?y1@+ ?y2).
:- axiom(plus:successor, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=> ?x@+s(?y)=s(?x)@+ ?y).
:- axiom(plus:successor, all[x,y]:succeeds nat(?x)=>s(?x)@+ ?y=s(?x@+ ?y)).
:- axiom(plus:termination:1, all[x,y,z]:succeeds nat(?x)=>terminates plus(?x,?y,?z)).
:- axiom(plus:termination:2, all[x,y,z]:succeeds nat(?z)=>terminates plus(?x,?y,?z)).
:- axiom(plus:termination:3, all[x,y,z]:succeeds plus(?x,?y,?z)=>terminates plus(?x,?y,?z)).
:- axiom(plus:times:distributive, all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)&succeeds nat(?z)=> ?z@*(?x@+ ?y)= ?z@* ?x@+ ?z@* ?y).
:- axiom(plus:times:distributive, all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)&succeeds nat(?z)=>(?x@+ ?y)@* ?z= ?x@* ?z@+ ?y@* ?z).
:- axiom(plus:types, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>succeeds nat(?x@+ ?y)).
:- axiom(plus:types:1, all[x,y,z]:succeeds plus(?x,?y,?z)=>succeeds nat(?x)).
:- axiom(plus:types:2, all[x,y,z]:succeeds plus(?x,?y,?z)&succeeds nat(?y)=>succeeds nat(?z)).
:- axiom(plus:types:3, all[x,y,z]:succeeds plus(?x,?y,?z)&succeeds nat(?z)=>succeeds nat(?y)).
:- axiom(plus:uniqueness, all[x,y,z1,z2]:succeeds plus(?x,?y,?z1)&succeeds plus(?x,?y,?z2)=> ?z1= ?z2).
:- axiom(plus:zero, all x:succeeds nat(?x)=> ?x@+0= ?x).
:- axiom(plus:zero, all y:0@+ ?y= ?y).
:- axiom(same_occ:success, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)&succeeds same_occ(?l1,?l2)=>(all x:occ(?x,?l1)=occ(?x,?l2))).
:- axiom(same_occ:termination, all[l1,l2]:succeeds list(?l1)&succeeds list(?l2)&gr(?l1)&gr(?l2)=>terminates same_occ(?l1,?l2)).
:- axiom(sub:app:1, all[l1,l2]:succeeds list(?l1)=>sub(?l1,?l1** ?l2)).
:- axiom(sub:app:2, all[l1,l2]:succeeds list(?l1)=>sub(?l2,?l1** ?l2)).
:- axiom(sub:cons, all[x,i]:sub(?i,[?x|?i])).
:- axiom(sub:cons:both, all[x,i,j]:sub(?i,?j)=>sub([?x|?i],[?x|?j])).
:- axiom(sub:member, all[x,i,j]:sub(?i,?j)&succeeds member(?x,?j)=>sub([?x|?i],?j)).
:- axiom(sub:nil, all l:sub([],?l)).
:- axiom(sub:reflexive, all l:sub(?l,?l)).
:- axiom(sub:transitive, all[i,j,k]:sub(?i,?j)&sub(?j,?k)=>sub(?i,?k)).
:- axiom(times:associative, all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)&succeeds nat(?z)=> ?x@* ?y@* ?z= ?x@*(?y@* ?z)).
:- axiom(times:commutative, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=> ?x@* ?y= ?y@* ?x).
:- axiom(times:existence, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>(ex z:succeeds times(?x,?y,?z))).
:- axiom(times:ground:1, all[x,y,z]:succeeds times(?x,?y,?z)=>gr(?x)).
:- axiom(times:ground:2, all[x,y,z]:succeeds times(?x,?y,?z)&gr(?y)=>gr(?z)).
:- axiom(times:leq:first, all[x,y,z]:succeeds?x@=< ?y&succeeds nat(?y)&succeeds nat(?z)=>succeeds?x@* ?z@=< ?y@* ?z).
:- axiom(times:leq:second, all[x,y,z]:succeeds nat(?x)&succeeds?y@=< ?z&succeeds nat(?z)=>succeeds?x@* ?y@=< ?x@* ?z).
:- axiom(times:less:second, all[x,y,z]:succeeds nat(?x)& ?x<>0&succeeds?y@< ?z&succeeds nat(?z)=>succeeds?x@* ?y@< ?x@* ?z).
:- axiom(times:one, all x:succeeds nat(?x)=> ?x@*s(0)= ?x).
:- axiom(times:one, all x:succeeds nat(?x)=>s(0)@* ?x= ?x).
:- axiom(times:successor, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>s(?x)@* ?y= ?y@+ ?x@* ?y).
:- axiom(times:successor, all[y,x]:succeeds nat(?y)&succeeds nat(?x)=> ?y@* ?x@+ ?y= ?y@*s(?x)).
:- axiom(times:termination, all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)=>terminates times(?x,?y,?z)).
:- axiom(times:types, all[x,y]:succeeds nat(?x)&succeeds nat(?y)=>succeeds nat(?x@* ?y)).
:- axiom(times:types:1, all[x,y,z]:succeeds times(?x,?y,?z)=>succeeds nat(?x)).
:- axiom(times:types:2, all[x,y,z]:succeeds times(?x,?y,?z)&succeeds nat(?y)=>succeeds nat(?z)).
:- axiom(times:uniqueness, all[x,y,z1,z2]:succeeds times(?x,?y,?z1)&succeeds times(?x,?y,?z2)=> ?z1= ?z2).
:- axiom(times:zero, all x:succeeds nat(?x)=> ?x@*0=0).
:- axiom(times:zero, all y:succeeds nat(?y)=>0@* ?y=0).
:- definition_pred(**, 2,all[l1,l2,l3]:succeeds list(?l1)=>(?l1** ?l2= ?l3<=>succeeds append(?l1,?l2,?l3))).
:- definition_pred(@*, 2,all[x,y,z]:succeeds nat(?x)&succeeds nat(?y)=>(?x@* ?y= ?z<=>succeeds times(?x,?y,?z))).
:- definition_pred(@+, 2,all[x,y,z]:succeeds nat(?x)=>(?x@+ ?y= ?z<=>succeeds plus(?x,?y,?z))).
:- definition_pred(lh, 1,all[l,n]:succeeds list(?l)=>(lh(?l)= ?n<=>succeeds length(?l,?n))).
:- definition_pred(occ, 2,all[x,l,m]:succeeds list(?l)=>(occ(?x,?l)= ?m<=>succeeds occ(?x,?l,?m))).
:- definition_pred(sub, 2,all[l1,l2]:sub(?l1,?l2)<=>(all x:succeeds member(?x,?l1)=>succeeds member(?x,?l2))).


:- axiom(leq:termination,
all [x,y]: succeeds integer(?x) & succeeds integer(?y) =>
  terminates ?x =< ?y
).

:- axiom(integer:gr,
all x: succeeds integer(?x) => gr(?x)
).

:- axiom(leq:total,
all [x,y]: succeeds integer(?x) & succeeds integer(?y) &
 fails ?x =< ?y => succeeds ?y =< ?x
).

:- lemma(int_list:list,
all l: succeeds int_list(?l) => succeeds list(?l),
induction([all l: succeeds int_list(?l) => succeeds list(?l)],
 [step([],[],[],succeeds list([])),
  step([x,l],
   [succeeds list(?l),
    succeeds integer(?x),
    succeeds int_list(?l)],
   [],
   succeeds list([?x|?l]))])
).

:- lemma(split:types,
all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) => succeeds list(?l1) &
  succeeds list(?l2) & succeeds list(?l3),
induction(
 [all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) => succeeds list(?l1) &
    succeeds list(?l2) & succeeds list(?l3)],
 [step([],[],[],succeeds list([]) & succeeds list([]) & succeeds list([])),
  step([x,xs,ys,zs],
   [succeeds list(?xs) & succeeds list(?zs) & succeeds list(?ys),
    succeeds split(?xs,?zs,?ys)],
   [],
   succeeds list([?x|?xs]) & succeeds list([?x|?ys]) & succeeds list(?zs))])
).

:- lemma(split:length,
all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) => lh(?l1) = lh(?l2) @+ lh(?l3),
induction(
 [all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) => 
    lh(?l1) = lh(?l2) @+ lh(?l3)],
 [step([],[],
   [lh([]) = 0 by corollary(lh:nil),
    0 @+ 0 = 0 by lemma(plus:zero),
    0 = 0 @+ 0,
    lh([]) = lh([]) @+ lh([])],
   lh([]) = lh([]) @+ lh([])),
  step([x,xs,ys,zs],
   [lh(?xs) = lh(?zs) @+ lh(?ys),
    succeeds split(?xs,?zs,?ys)],
   [succeeds list(?xs) & succeeds list(?zs) & succeeds list(?ys) by lemma(split:types),
    lh([?x|?xs]) = s(lh(?xs)) by corollary(lh:cons),
    lh([?x|?ys]) = s(lh(?ys)) by corollary(lh:cons),
    succeeds nat(lh(?ys)) by corollary(lh:types),
    succeeds nat(lh(?zs)) by corollary(lh:types),
    lh(?zs) @+ lh(?ys) = lh(?ys) @+ lh(?zs) by theorem(plus:commutative),
    lh(?xs) = lh(?ys) @+ lh(?zs),
    s(lh(?ys)) @+ lh(?zs) = s(lh(?ys) @+ lh(?zs)) by 
     corollary(plus:successor),
    lh([?x|?xs]) = s(lh(?xs)) = s(lh(?ys) @+ lh(?zs)) =
    s(lh(?ys)) @+ lh(?zs) = lh([?x|?ys]) @+ lh(?zs) ,
    lh([?x|?xs]) = lh([?x|?ys]) @+ lh(?zs)],
   lh([?x|?xs]) = lh([?x|?ys]) @+ lh(?zs))])
).

:- lemma(split:termination,
all [l1,l2,l3]: succeeds list(?l1) => terminates split(?l1,?l2,?l3),
[induction(
  [all l1: succeeds list(?l1) => 
     (all [l2,l3]: terminates split(?l1,?l2,?l3))],
  [step([],
    [],
    terminates split([],?l2,?l3),
    all [l2,l3]: terminates split([],?l2,?l3)),
   step([x,l],
    [all [l2,l3]: terminates split(?l,?l2,?l3),
     succeeds list(?l)],
    [terminates split(?l,?l3,?l2),
     ?l2 = [?x|?ys] => terminates split(?l,?l3,?ys),
     all ys: ?l2 = [?x|?ys] => terminates split(?l,?l3,?ys),
     terminates split([?x|?l],?l2,?l3) by completion],
    all [l2,l3]: terminates split([?x|?l],?l2,?l3))]),
 assume(succeeds list(?l1),
  [all [l2,l3]: terminates split(?l1,?l2,?l3),
   terminates split(?l1,?l2,?l3)],
  terminates split(?l1,?l2,?l3))]
).

:- lemma(merge:types,
all [l1,l2,l3]: succeeds merge(?l1,?l2,?l3) & succeeds int_list(?l1) &
 succeeds int_list(?l2) => succeeds int_list(?l3),
[induction(
  [all [l1,l2,l3]: succeeds merge(?l1,?l2,?l3) => succeeds int_list(?l1) &
     succeeds int_list(?l2) => succeeds int_list(?l3)],
  [step([xs],
    [],
    assume(succeeds int_list([]) & succeeds int_list(?xs),
     [],
     succeeds int_list(?xs)),
    succeeds int_list([]) & succeeds int_list(?xs) => 
     succeeds int_list(?xs)),
   step([xs],
    [],
    assume(succeeds int_list(?xs) & succeeds int_list([]),
     [],
     succeeds int_list(?xs)),
    succeeds int_list(?xs) & succeeds int_list([]) => 
     succeeds int_list(?xs)),
   step([x,xs,y,ys,z,zs],
    [succeeds int_list(?xs) & succeeds int_list([?y|?ys]) => 
      succeeds int_list(?zs),
     succeeds ?x =< ?y,
     ?z = ?x,
     succeeds merge(?xs,[?y|?ys],?zs)],
    assume(succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]),
     [def succeeds int_list([?x|?xs]) by completion,
      succeeds int_list([?z|?zs])],
     succeeds int_list([?z|?zs])),
    succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) => 
     succeeds int_list([?z|?zs])),
   step([x,xs,y,ys,z,zs],
    [succeeds int_list([?x|?xs]) & succeeds int_list(?ys) => 
      succeeds int_list(?zs),
     fails ?x =< ?y,
     ?z = ?y,
     succeeds merge([?x|?xs],?ys,?zs)],
    assume(succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]),
     [def succeeds int_list([?y|?ys]) by completion,
      succeeds int_list([?z|?zs]) by completion],
     succeeds int_list([?z|?zs])),
    succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) => 
     succeeds int_list([?z|?zs]))]),
 assume(succeeds merge(?l1,?l2,?l3) & succeeds int_list(?l1) &
  succeeds int_list(?l2),
  [succeeds int_list(?l1) & succeeds int_list(?l2) => 
    succeeds int_list(?l3),
   succeeds int_list(?l1) & succeeds int_list(?l2) => 
    succeeds int_list(?l3),
   succeeds int_list(?l3)],
  succeeds int_list(?l3))]
).

:- lemma(split:types:2,
all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) & succeeds int_list(?l1) =>
  succeeds int_list(?l2) & succeeds int_list(?l3),
[induction(
  [all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) => succeeds int_list(?l1) =>
      succeeds int_list(?l2) & succeeds int_list(?l3)],
  [step([],
    [],
    [],
    succeeds int_list([]) => succeeds int_list([]) & succeeds int_list([])),
   step([x,xs,ys,zs],
    [succeeds int_list(?xs) => succeeds int_list(?zs) &
      succeeds int_list(?ys),
     succeeds split(?xs,?zs,?ys)],
    assume(succeeds int_list([?x|?xs]),
     [def succeeds int_list([?x|?xs]) by completion,
      succeeds int_list(?zs) &
      succeeds int_list(?ys),
      succeeds int_list([?x|?ys]),
      succeeds int_list(?zs)],
     succeeds int_list([?x|?ys]) & succeeds int_list(?zs)),
    succeeds int_list([?x|?xs]) => succeeds int_list([?x|?ys]) &
     succeeds int_list(?zs))]),
 assume(succeeds split(?l1,?l2,?l3) & succeeds int_list(?l1),
  [succeeds int_list(?l1) => succeeds int_list(?l2) & 
    succeeds int_list(?l3),
   succeeds int_list(?l1) => succeeds int_list(?l2) & 
    succeeds int_list(?l3),
   succeeds int_list(?l2) & succeeds int_list(?l3)],
  succeeds int_list(?l2) & succeeds int_list(?l3))]
).

:- lemma(mergesort:types,
all [l1,l2]: succeeds mergesort(?l1,?l2) & succeeds int_list(?l1) =>
  succeeds int_list(?l2),
[induction(
  [all [l1,l2]: succeeds mergesort(?l1,?l2) => succeeds int_list(?l1) => 
      succeeds int_list(?l2)],
  [step([],[],[],succeeds int_list([]) => succeeds int_list([])),
   step([x],
    [],
    [],
    succeeds int_list([?x]) => succeeds int_list([?x])),
   step([x,y,xs,ys,xs1,xs2,ys1,ys2],
    [succeeds int_list(?xs1) => succeeds int_list(?ys1),
     succeeds int_list(?xs2) => succeeds int_list(?ys2),
     succeeds split([?x,?y|?xs],?xs1,?xs2),
     succeeds mergesort(?xs1,?ys1),
     succeeds mergesort(?xs2,?ys2),
     succeeds merge(?ys1,?ys2,?ys)],
    assume(succeeds int_list([?x,?y|?xs]),
     [succeeds int_list(?xs1) & succeeds int_list(?xs2) by lemma(split:types:2),
      succeeds int_list(?ys1),
      succeeds int_list(?ys2),
      succeeds int_list(?ys) by lemma(merge:types) ],
     succeeds int_list(?ys)),
    succeeds int_list([?x,?y|?xs]) => succeeds int_list(?ys))]),
 assume(succeeds mergesort(?l1,?l2) & succeeds int_list(?l1),
  [succeeds int_list(?l1) => succeeds int_list(?l2),
   succeeds int_list(?l1) => succeeds int_list(?l2),
   succeeds int_list(?l2)],
  succeeds int_list(?l2))]
).

:- lemma(merge:termination,
all n: succeeds nat(?n) =>
  (all [l1,l2,l3]: succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< ?n => terminates merge(?l1,?l2,?l3)),
induction(
 [all n: succeeds nat(?n) => 
    (all [l1,l2,l3]: succeeds int_list(?l1) & succeeds int_list(?l2) &
      succeeds lh(?l1) @+ lh(?l2) @< ?n => terminates merge(?l1,?l2,?l3))],
 [step([],
   [],
   assume(succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< 0,
    [def succeeds lh(?l1) @+ lh(?l2) @< 0 by completion,
     terminates merge(?l1,?l2,?l3)],
    terminates merge(?l1,?l2,?l3)),
   all [l1,l2,l3]: succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< 0 => terminates merge(?l1,?l2,?l3)),
  step([n],
   [all [l1,l2,l3]: succeeds int_list(?l1) & succeeds int_list(?l2) &
     succeeds lh(?l1) @+ lh(?l2) @< ?n => terminates merge(?l1,?l2,?l3),
    succeeds nat(?n)],
   assume(succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< s(?n),
    [assume(?l1 = [?x|?xs] & ?l2 = [?y|?ys] & ?l3 = [?z|?zs],
      [def succeeds int_list([?x|?xs]) by completion,
       def succeeds int_list([?y|?ys]) by completion,
       terminates ?x =< ?y by axiom(leq:termination),
       succeeds list(?xs) by lemma(int_list:list),
       succeeds list(?l1),
       succeeds list(?ys) by lemma(int_list:list),
       succeeds list(?l2),
       succeeds lh([?x|?xs]) @+ lh([?y|?ys]) @< s(?n),
       succeeds lh(?xs) @+ lh([?y|?ys]) @< ?n by lemma(lh:cons:first),
       terminates merge(?xs,[?y|?ys],?zs),
       terminates (?x =< ?y & ?z = ?x & merge(?xs,[?y|?ys],?zs)),
       gr(?x) by axiom(integer:gr),
       gr(?y) by axiom(integer:gr),
       succeeds list(?ys) by lemma(int_list:list),
       succeeds lh(?l1) @+ lh(?ys) @< ?n by lemma(lh:cons:second),
       succeeds lh([?x|?xs]) @+ lh(?ys) @< ?n,
       terminates merge([?x|?xs],?ys,?zs),
       terminates (~ ?x =< ?y & ?z = ?y & merge([?x|?xs],?ys,?zs))],
      terminates (?x =< ?y & ?z = ?x & merge(?xs,[?y|?ys],?zs)) &
      terminates (~ ?x =< ?y & ?z = ?y & merge([?x|?xs],?ys,?zs))),
     all [x,xs,y,ys,z,zs]: ?l1 = [?x|?xs] & ?l2 = [?y|?ys] & ?l3 = [?z|?zs] =>
       terminates (?x =< ?y & ?z = ?x & merge(?xs,[?y|?ys],?zs)) &
       terminates (~ ?x =< ?y & ?z = ?y & merge([?x|?xs],?ys,?zs)),
     terminates merge(?l1,?l2,?l3) by completion],
    terminates merge(?l1,?l2,?l3)),
   all [l1,l2,l3]: succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< s(?n) => terminates merge(?l1,?l2,?l3))])
).

:- theorem(merge:termination,
all [l1,l2,l3]: succeeds int_list(?l1) & succeeds int_list(?l2) =>
  terminates merge(?l1,?l2,?l3),
assume(succeeds int_list(?l1) & succeeds int_list(?l2),
 [succeeds list(?l1) by lemma(int_list:list),
  succeeds list(?l2) by lemma(int_list:list),
  succeeds nat(lh(?l1)) by corollary(lh:types),
  succeeds nat(lh(?l2)) by corollary(lh:types),
  succeeds nat(lh(?l1) @+ lh(?l2)) by corollary(plus:types),
  succeeds lh(?l1) @+ lh(?l2) @< s(lh(?l1) @+ lh(?l2)) by lemma(less:one),
  succeeds nat(s(lh(?l1) @+ lh(?l2))),
  all [m1,m2,m3]: succeeds int_list(?m1) & succeeds int_list(?m2) &
   succeeds lh(?m1) @+ lh(?m2) @< s(lh(?l1) @+ lh(?l2)) => 
    terminates merge(?m1,?m2,?m3) by lemma(merge:termination), 
  terminates merge(?l1,?l2,?l3) ],
 terminates merge(?l1,?l2,?l3))
).

:- lemma(split:length:less,
all [x,y,l1,l2,l3]: succeeds split([?x,?y|?l1],?l2,?l3) =>
  succeeds lh(?l2) @< lh([?x,?y|?l1]) &
  succeeds lh(?l3) @< lh([?x,?y|?l1]),
assume(succeeds split([?x,?y|?l1],?l2,?l3),
 [def succeeds split([?x,?y|?l1],?l2,?l3) by completion,
  exist(xs,
   ?l2 = [?x|?xs] & succeeds split([?y|?l1],?l3,?xs),
   [def succeeds split([?y|?l1],?l3,?xs) by completion,
    exist(ys,
     ?l3 = [?y|?ys] & succeeds split(?l1,?xs,?ys),
     [lh(?l1) = lh(?xs) @+ lh(?ys) by lemma(split:length),
      succeeds list(?l1) & succeeds list(?xs) & succeeds list(?ys) by lemma(split:types),
      succeeds nat(lh(?xs)) by corollary(lh:types),
      succeeds nat(lh(?ys)) by corollary(lh:types),
      succeeds nat(lh(?l1)) by corollary(lh:types),
      succeeds lh(?xs) @=< lh(?xs) @+ lh(?ys) by 
       corollary(leq:plus:first),
      succeeds lh(?ys) @=< lh(?xs) @+ lh(?ys) by 
       corollary(leq:plus:second),
      succeeds lh(?xs) @=< lh(?l1),
      succeeds lh(?ys) @=< lh(?l1),
      succeeds s(lh(?xs)) @=< s(lh(?l1)) by sld,
      succeeds s(lh(?ys)) @=< s(lh(?l1)) by sld,
      lh([?x|?xs]) = s(lh(?xs)) by corollary(lh:cons),
      lh([?y|?ys]) = s(lh(?ys)) by corollary(lh:cons),
      lh(?l2) = s(lh(?xs)),
      lh(?l3) = s(lh(?ys)),
      lh([?y|?l1]) = s(lh(?l1)) by corollary(lh:cons),
      succeeds lh(?l2) @=< lh([?y|?l1]),
      succeeds lh(?l3) @=< lh([?y|?l1]),
      lh([?x,?y|?l1]) = s(lh([?y|?l1])) by corollary(lh:cons),
      succeeds lh([?y|?l1]) @< s(lh([?y|?l1])) by lemma(less:one),
      succeeds lh([?y|?l1]) @< lh([?x,?y|?l1]),
      succeeds lh(?l2) @< lh([?x,?y|?l1]) by theorem(leq:less:transitive),
      succeeds lh(?l3) @< lh([?x,?y|?l1]) by theorem(leq:less:transitive)],
     succeeds lh(?l2) @< lh([?x,?y|?l1]) &
     succeeds lh(?l3) @< lh([?x,?y|?l1]))],
   succeeds lh(?l2) @< lh([?x,?y|?l1]) & 
   succeeds lh(?l3) @< lh([?x,?y|?l1]))],
 succeeds lh(?l2) @< lh([?x,?y|?l1]) & succeeds lh(?l3) @< lh([?x,?y|?l1]))
).

:- lemma(mergesort:termination,
all n: succeeds nat(?n) =>
  (all [l1,l2]: succeeds int_list(?l1) & succeeds lh(?l1) @< ?n =>
     terminates mergesort(?l1,?l2)),
induction(
 [all n: succeeds nat(?n) => 
    (all [l1,l2]: succeeds int_list(?l1) & succeeds lh(?l1) @< ?n => 
       terminates mergesort(?l1,?l2))],
 [step([],
   [],
   assume(succeeds int_list(?l1) & succeeds lh(?l1) @< 0,
    [def succeeds lh(?l1) @< 0 by completion,
     terminates mergesort(?l1,?l2)],
    terminates mergesort(?l1,?l2)),
   all [l1,l2]: succeeds int_list(?l1) & succeeds lh(?l1) @< 0 => 
     terminates mergesort(?l1,?l2)),
  step([n],
   [all [l1,l2]: succeeds int_list(?l1) & succeeds lh(?l1) @< ?n => 
      terminates mergesort(?l1,?l2),
    succeeds nat(?n)],
   assume(succeeds int_list(?l1) & succeeds lh(?l1) @< s(?n),
    [assume(?l1 = [?x,?y|?xs],
      [succeeds list(?l1) by lemma(int_list:list),
       terminates split([?x,?y|?xs],?xs1,?xs2) by lemma(split:termination),
       assume(succeeds split([?x,?y|?xs],?xs1,?xs2),
	[succeeds int_list(?xs1) & succeeds int_list(?xs2) by lemma(split:types:2),
	 succeeds lh(?xs1) @< lh([?x,?y|?xs]) &
         succeeds lh(?xs2) @< lh([?x,?y|?xs]) by lemma(split:length:less),
	 succeeds lh(?xs1) @< lh(?l1),
	 succeeds lh(?xs2) @< lh(?l1),
	 succeeds nat(lh(?xs1)) by lemma(less:types),
	 succeeds nat(lh(?xs2)) by lemma(less:types),
	 succeeds nat(lh(?l1)) by lemma(less:types),
	 succeeds lh(?xs1) @< ?n by lemma(less:transitive:successor),
	 succeeds lh(?xs2) @< ?n by lemma(less:transitive:successor),
	 terminates mergesort(?xs1,?ys1),
	 terminates mergesort(?xs2,?ys2),
	 assume(succeeds mergesort(?xs1,?ys1),
	  [assume(succeeds mergesort(?xs2,?ys2),
            [succeeds int_list(?ys1) by lemma(mergesort:types),
	     succeeds int_list(?ys2) by lemma(mergesort:types),
	     terminates merge(?ys1,?ys2,?l2) by theorem(merge:termination)],
            terminates merge(?ys1,?ys2,?l2)),
           terminates (mergesort(?xs2,?ys2) & merge(?ys1,?ys2,?l2))],
	  terminates (mergesort(?xs2,?ys2) & merge(?ys1,?ys2,?l2))),
	 terminates 
	 (mergesort(?xs1,?ys1) & mergesort(?xs2,?ys2) &
	  merge(?ys1,?ys2,?l2))],
	terminates 
	(mergesort(?xs1,?ys1) & mergesort(?xs2,?ys2) & 
	 merge(?ys1,?ys2,?l2))),
       terminates 
       (split([?x,?y|?xs],?xs1,?xs2) & mergesort(?xs1,?ys1) &
	mergesort(?xs2,?ys2) & merge(?ys1,?ys2,?l2))],
      terminates 
      (split([?x,?y|?xs],?xs1,?xs2) & mergesort(?xs1,?ys1) &
       mergesort(?xs2,?ys2) & merge(?ys1,?ys2,?l2))),
     all [x,y,xs,xs1,xs2,ys1,ys2]: ?l1 = [?x,?y|?xs] => 
       terminates 
       (split([?x,?y|?xs],?xs1,?xs2) & mergesort(?xs1,?ys1) &
        mergesort(?xs2,?ys2) & merge(?ys1,?ys2,?l2)),
     terminates mergesort(?l1,?l2) by completion],
    terminates mergesort(?l1,?l2)),
   all [l1,l2]: succeeds int_list(?l1) & succeeds lh(?l1) @< s(?n) => 
     terminates mergesort(?l1,?l2))])
).

:- theorem(mergesort:termiation,
all [l1,l2]: succeeds int_list(?l1) => terminates mergesort(?l1,?l2),
assume(succeeds int_list(?l1),
 [succeeds list(?l1) by lemma(int_list:list),
  succeeds nat(lh(?l1)) by corollary(lh:types),
  succeeds lh(?l1) @< s(lh(?l1)) by lemma(less:one),
  all [m1,m2]: succeeds int_list(?m1) & succeeds lh(?m1) @< s(lh(?l1)) => 
    terminates mergesort(?m1,?m2) by lemma(mergesort:termination),
  terminates mergesort(?l1,?l2) ],
 terminates mergesort(?l1,?l2))
).

:- lemma(split:existence,
all l1: succeeds list(?l1) => (ex [l2,l3]: succeeds split(?l1,?l2,?l3)),
induction(
 [all l1: succeeds list(?l1) => (ex [l2,l3]: succeeds split(?l1,?l2,?l3))],
 [step([],
   [],
   [succeeds split([],[],[]) by sld,
    ex [l2,l3]: succeeds split([],?l2,?l3)],
   ex [l2,l3]: succeeds split([],?l2,?l3)),
  step([x,l],
   [ex [l2,l3]: succeeds split(?l,?l2,?l3),
    succeeds list(?l)],
   exist([l2,l3],
    succeeds split(?l,?l2,?l3),
    [succeeds split([?x|?l],[?x|?l3],?l2) by sld,
     ex [l2,l3]: succeeds split([?x|?l],?l2,?l3)],
    ex [l2,l3]: succeeds split([?x|?l],?l2,?l3)),
   ex [l2,l3]: succeeds split([?x|?l],?l2,?l3))])
).

:- lemma(merge:existence,
all n: succeeds nat(?n) =>
  (all [l1,l2]: succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< ?n =>
     (ex l3: succeeds merge(?l1,?l2,?l3))),
induction(
 [all n: succeeds nat(?n) => 
    (all [l1,l2]: succeeds int_list(?l1) & succeeds int_list(?l2) &
      succeeds lh(?l1) @+ lh(?l2) @< ?n => 
       (ex l3: succeeds merge(?l1,?l2,?l3)))],
 [step([],
   [],
   assume(succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< 0,
    [def succeeds lh(?l1) @+ lh(?l2) @< 0 by completion,
     ex l3: succeeds merge(?l1,?l2,?l3)],
    ex l3: succeeds merge(?l1,?l2,?l3)),
   all [l1,l2]: succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< 0 => 
     (ex l3: succeeds merge(?l1,?l2,?l3))),
  step([n],
   [all [l1,l2]: succeeds int_list(?l1) & succeeds int_list(?l2) &
     succeeds lh(?l1) @+ lh(?l2) @< ?n => 
      (ex l3: succeeds merge(?l1,?l2,?l3)),
    succeeds nat(?n)],
   assume(succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< s(?n),
    [def succeeds int_list(?l1)  by completion,
     cases(?l1 = [],
      [succeeds merge([],?l2,?l2) by sld,
       succeeds merge(?l1,?l2,?l2),
       ex l3: succeeds merge(?l1,?l2,?l3)],
      ex [x,xs]: ?l1 = [?x|?xs] & succeeds integer(?x) & 
       succeeds int_list(?xs),
      exist([x,xs],
       ?l1 = [?x|?xs] & succeeds integer(?x) & succeeds int_list(?xs),
       [def succeeds int_list(?l2) by completion,
	cases(?l2 = [],
         [succeeds merge(?l1,[],?l1) by sld,
	  succeeds merge(?l1,?l2,?l1),
	  ex l3: succeeds merge(?l1,?l2,?l3)],
         ex [y,ys]: ?l2 = [?y|?ys] & succeeds integer(?y) &
          succeeds int_list(?ys),
         exist([y,ys],
          ?l2 = [?y|?ys] & succeeds integer(?y) & succeeds int_list(?ys),
          [terminates ?x =< ?y by axiom(leq:termination),
	   succeeds ?x =< ?y \/ fails ?x =< ?y,
	   cases(succeeds ?x =< ?y,
	    [succeeds list(?xs) by lemma(int_list:list),
	     succeeds list(?l2) by lemma(int_list:list),
	     succeeds lh([?x|?xs]) @+ lh(?l2) @< s(?n),
	     succeeds lh(?xs) @+ lh(?l2) @< ?n by lemma(lh:cons:first),
	     ex l3: succeeds merge(?xs,?l2,?l3),
	     exist(l3,
              succeeds merge(?xs,?l2,?l3),
              [succeeds merge(?xs,[?y|?ys],?l3),
	       ?x = ?x,
	       succeeds merge([?x|?xs],[?y|?ys],[?x|?l3]) by sld,
	       succeeds merge(?l1,?l2,[?x|?l3]),
	       ex l3: succeeds merge(?l1,?l2,?l3)],
              ex l3: succeeds merge(?l1,?l2,?l3))],
	    fails ?x =< ?y,
	    [succeeds list(?l1) by lemma(int_list:list),
	     succeeds list(?ys) by lemma(int_list:list),
	     succeeds lh(?l1) @+ lh([?y|?ys]) @< s(?n),
	     succeeds lh(?l1) @+ lh(?ys) @< ?n by lemma(lh:cons:second),
	     ex l3: succeeds merge(?l1,?ys,?l3),
	     exist(l3,
              succeeds merge(?l1,?ys,?l3),
              [succeeds merge([?x|?xs],?ys,?l3),
	       ?y = ?y,
	       succeeds merge([?x|?xs],[?y|?ys],[?y|?l3]) by sld,
	       succeeds merge(?l1,?l2,[?y|?l3]),
	       ex l3: succeeds merge(?l1,?l2,?l3)],
              ex l3: succeeds merge(?l1,?l2,?l3))],
	    ex l3: succeeds merge(?l1,?l2,?l3))],
          ex l3: succeeds merge(?l1,?l2,?l3)),
         ex l3: succeeds merge(?l1,?l2,?l3))],
       ex l3: succeeds merge(?l1,?l2,?l3)),
      ex l3: succeeds merge(?l1,?l2,?l3))],
    ex l3: succeeds merge(?l1,?l2,?l3)),
   all [l1,l2]: succeeds int_list(?l1) & succeeds int_list(?l2) &
    succeeds lh(?l1) @+ lh(?l2) @< s(?n) => 
     (ex l3: succeeds merge(?l1,?l2,?l3)))])
).

:- theorem(merge:existence,
all [l1,l2]: succeeds int_list(?l1) & succeeds int_list(?l2) =>
  (ex l3: succeeds merge(?l1,?l2,?l3)),
assume(succeeds int_list(?l1) & succeeds int_list(?l2),
 [succeeds list(?l1) by lemma(int_list:list),
  succeeds list(?l2) by lemma(int_list:list),
  succeeds nat(lh(?l1)) by corollary(lh:types),
  succeeds nat(lh(?l2)) by corollary(lh:types),
  succeeds nat(lh(?l1) @+ lh(?l2)) by corollary(plus:types),
  succeeds lh(?l1) @+ lh(?l2) @< s(lh(?l1) @+ lh(?l2)) by lemma(less:one),
  succeeds nat(s(lh(?l1) @+ lh(?l2))),
  all [m1,m2]: succeeds int_list(?m1) & succeeds int_list(?m2) &
   succeeds lh(?m1) @+ lh(?m2) @< s(lh(?l1) @+ lh(?l2)) => 
    (ex l3: succeeds merge(?m1,?m2,?l3)) by lemma(merge:existence),
  ex l3: succeeds merge(?l1,?l2,?l3)],
 ex l3: succeeds merge(?l1,?l2,?l3))
).

:- lemma(mergesort:existence,
all n: succeeds nat(?n) =>
  (all l1: succeeds int_list(?l1) & succeeds lh(?l1) @< ?n =>
     (ex l2: succeeds mergesort(?l1,?l2))),
induction(
 [all n: succeeds nat(?n) => 
    (all l1: succeeds int_list(?l1) & succeeds lh(?l1) @< ?n => 
       (ex l2: succeeds mergesort(?l1,?l2)))],
 [step([],
   [],
   assume(succeeds int_list(?l1) & succeeds lh(?l1) @< 0,
    [def succeeds lh(?l1) @< 0 by completion,
     ex l2: succeeds mergesort(?l1,?l2)],
    ex l2: succeeds mergesort(?l1,?l2)),
   all l1: succeeds int_list(?l1) & succeeds lh(?l1) @< 0 => 
     (ex l2: succeeds mergesort(?l1,?l2))),
  step([n],
   [all l1: succeeds int_list(?l1) & succeeds lh(?l1) @< ?n => 
      (ex l2: succeeds mergesort(?l1,?l2)),
    succeeds nat(?n)],
   assume(succeeds int_list(?l1) & succeeds lh(?l1) @< s(?n),
    [def succeeds int_list(?l1) by completion,
     cases(?l1 = [],
      [succeeds mergesort([],[]) by sld,
       succeeds mergesort(?l1,[]),
       ex l2: succeeds mergesort(?l1,?l2)],
      ex [x,l]: ?l1 = [?x|?l] & succeeds integer(?x) & 
       succeeds int_list(?l),
      exist([x,l],
       ?l1 = [?x|?l] & succeeds integer(?x) & succeeds int_list(?l),
       [def succeeds int_list(?l) by completion,
        cases(?l = [],
         [?l1 = [?x],
	  succeeds mergesort([?x],[?x]) by sld,
	  succeeds mergesort(?l1,[?x]),
	  ex l2: succeeds mergesort(?l1,?l2)],
         ex [x,xs]: ?l = [?x|?xs] & succeeds integer(?x) &
          succeeds int_list(?xs),
         exist([y,xs],
          ?l = [?y|?xs] & succeeds integer(?y) & succeeds int_list(?xs),
          [?l1 = [?x,?y|?xs],
	   succeeds list(?l1) by lemma(int_list:list),
	   ex [xs1,xs2]: succeeds split([?x,?y|?xs],?xs1,?xs2) by lemma(split:existence),
	   exist([xs1,xs2],
            succeeds split([?x,?y|?xs],?xs1,?xs2),
            [succeeds int_list(?xs1) & succeeds int_list(?xs2) by lemma(split:types:2),
	     succeeds lh(?xs1) @< lh([?x,?y|?xs]) &
	     succeeds lh(?xs2) @< lh([?x,?y|?xs]) by lemma(split:length:less),
	     succeeds lh(?xs1) @< lh(?l1),
	     succeeds lh(?xs2) @< lh(?l1),
	     succeeds nat(lh(?xs1)) by lemma(less:types),
	     succeeds nat(lh(?xs2)) by lemma(less:types),
	     succeeds nat(lh(?l1)) by lemma(less:types),
	     succeeds lh(?xs1) @< ?n by lemma(less:transitive:successor),
	     succeeds lh(?xs2) @< ?n by lemma(less:transitive:successor),
	     ex ys1: succeeds mergesort(?xs1,?ys1),
	     exist(ys1,
              succeeds mergesort(?xs1,?ys1),
              [ex ys2: succeeds mergesort(?xs2,?ys2),
	       exist(ys2,
                succeeds mergesort(?xs2,?ys2),
                [succeeds int_list(?ys1) by lemma(mergesort:types),
		 succeeds int_list(?ys2) by lemma(mergesort:types),
		 ex ys: succeeds merge(?ys1,?ys2,?ys) by theorem(merge:existence),
		 exist(ys,
                  succeeds merge(?ys1,?ys2,?ys),
                  [succeeds mergesort([?x,?y|?xs],?ys) by sld,
		   succeeds mergesort(?l1,?ys),
		   ex l2: succeeds mergesort(?l1,?l2)],
                  ex l2: succeeds mergesort(?l1,?l2))],
                ex l2: succeeds mergesort(?l1,?l2))],
              ex l2: succeeds mergesort(?l1,?l2))],
            ex l2: succeeds mergesort(?l1,?l2))],
          ex l2: succeeds mergesort(?l1,?l2)),
         ex l2: succeeds mergesort(?l1,?l2))],
       ex l2: succeeds mergesort(?l1,?l2)),
      ex l2: succeeds mergesort(?l1,?l2))],
    ex l2: succeeds mergesort(?l1,?l2)),
   all l1: succeeds int_list(?l1) & succeeds lh(?l1) @< s(?n) => 
     (ex l2: succeeds mergesort(?l1,?l2)))]) 
).

:- theorem(mergesort:existence,
all l1: succeeds int_list(?l1) => (ex l2: succeeds mergesort(?l1,?l2)),
assume(succeeds int_list(?l1),
 [succeeds list(?l1) by lemma(int_list:list),
  succeeds nat(lh(?l1)) by corollary(lh:types),
  succeeds lh(?l1) @< s(lh(?l1)) by lemma(less:one),
  all m1: succeeds int_list(?m1) & succeeds lh(?m1) @< s(lh(?l1)) => 
    (ex l2: succeeds mergesort(?m1,?l2)) by lemma(mergesort:existence),
  ex l2: succeeds mergesort(?l1,?l2)],
 ex l2: succeeds mergesort(?l1,?l2))
).

:- lemma(split:permutation,
all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) =>
  succeeds permutation(?l1,?l2 ** ?l3),
induction(
 [all [l1,l2,l3]: succeeds split(?l1,?l2,?l3) => 
    succeeds permutation(?l1,?l2 ** ?l3)],
 [step([],
   [],
   [[] ** [] = [] by lemma(app:nil),
    succeeds permutation([],[]),
    succeeds permutation([],[] ** [])],
   succeeds permutation([],[] ** [])),
  step([x,xs,ys,zs],
   [succeeds permutation(?xs,?zs ** ?ys),
    succeeds split(?xs,?zs,?ys)],
   [succeeds list(?xs) & succeeds list(?zs) & succeeds list(?ys) by lemma(split:types),
    [?x|?ys] ** ?zs = [?x|?ys ** ?zs] by corollary(app:cons),
    succeeds delete(?x,[?x|?xs],?xs) by sld,
    succeeds permutation(?zs ** ?ys,?ys ** ?zs) by theorem(permutation:app:commutative),
    succeeds permutation(?xs,?ys ** ?zs) by theorem(permutation:transitive),
    succeeds permutation([?x|?xs],[?x|?ys ** ?zs]) by sld,
    succeeds permutation([?x|?xs],[?x|?ys] ** ?zs)],
   succeeds permutation([?x|?xs],[?x|?ys] ** ?zs))])
).

:- lemma(merge:permutation,
all [l1,l2,l3]: succeeds merge(?l1,?l2,?l3) &
 succeeds int_list(?l1) & succeeds int_list(?l2) =>
  succeeds permutation(?l1 ** ?l2,?l3),
[induction(
  [all [l1,l2,l3]: succeeds merge(?l1,?l2,?l3) => succeeds int_list(?l1) &
     succeeds int_list(?l2) => succeeds permutation(?l1 ** ?l2,?l3)],
  [step([xs],
    [],
    assume(succeeds int_list([]) & succeeds int_list(?xs),
     [succeeds list(?xs) by lemma(int_list:list),
      [] ** ?xs = ?xs by corollary(app:nil),
      succeeds permutation(?xs,?xs) by theorem(permutation:reflexive),
      succeeds permutation([] ** ?xs,?xs)],
     succeeds permutation([] ** ?xs,?xs)),
    succeeds int_list([]) & succeeds int_list(?xs) => 
     succeeds permutation([] ** ?xs,?xs)),
   step([xs],
    [],
    assume(succeeds int_list(?xs) & succeeds int_list([]),
     [succeeds list(?xs) by lemma(int_list:list),
      ?xs ** [] = ?xs by lemma(app:nil),
      succeeds permutation(?xs,?xs) by theorem(permutation:reflexive),
      succeeds permutation(?xs ** [],?xs)],
     succeeds permutation(?xs ** [],?xs)),
    succeeds int_list(?xs) & succeeds int_list([]) => 
     succeeds permutation(?xs ** [],?xs)),
   step([x,xs,y,ys,z,zs],
    [succeeds int_list(?xs) & succeeds int_list([?y|?ys]) => 
      succeeds permutation(?xs ** [?y|?ys],?zs),
     succeeds ?x =< ?y,
     ?z = ?x,
     succeeds merge(?xs,[?y|?ys],?zs)],
    assume(succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]),
     [succeeds list([?x|?xs]) by lemma(int_list:list),
      succeeds list([?y|?ys]) by lemma(int_list:list),
      def succeeds list([?x|?xs]) by completion,
      [?x|?xs] ** [?y|?ys] = [?x|?xs ** [?y|?ys]] by corollary(app:cons),
      succeeds delete(?x,[?x|?xs ** [?y|?ys]],?xs ** [?y|?ys]) by sld,
      def succeeds int_list([?x|?xs]) by completion,
      succeeds permutation(?xs ** [?y|?ys],?zs),
      succeeds permutation([?x|?xs ** [?y|?ys]],[?x|?zs]) by sld,
      succeeds permutation([?x|?xs] ** [?y|?ys],[?z|?zs])],
     succeeds permutation([?x|?xs] ** [?y|?ys],[?z|?zs])),
    succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) => 
     succeeds permutation([?x|?xs] ** [?y|?ys],[?z|?zs])),
   step([x,xs,y,ys,z,zs],
    [succeeds int_list([?x|?xs]) & succeeds int_list(?ys) => 
      succeeds permutation([?x|?xs] ** ?ys,?zs),
     fails ?x =< ?y,
     ?z = ?y,
     succeeds merge([?x|?xs],?ys,?zs)],
    assume(succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]),
     [def succeeds int_list([?y|?ys]) by completion,
      succeeds permutation([?x|?xs] ** ?ys,?zs),
      succeeds list([?x|?xs]) by lemma(int_list:list),
      succeeds list([?y|?ys]) by lemma(int_list:list),
      succeeds list(?xs) by lemma(list:cons),
      succeeds delete(?y,[?x|?xs] ** [?y|?ys],[?x|?xs] ** ?ys) by theorem(delete:app:1),
      succeeds permutation([?x|?xs] ** [?y|?ys],[?y|?zs]) by sld,
      succeeds permutation([?x|?xs] ** [?y|?ys],[?z|?zs])],
     succeeds permutation([?x|?xs] ** [?y|?ys],[?z|?zs])),
    succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) => 
     succeeds permutation([?x|?xs] ** [?y|?ys],[?z|?zs]))]),
 assume(succeeds merge(?l1,?l2,?l3) & succeeds int_list(?l1) &
  succeeds int_list(?l2),
  [succeeds int_list(?l1) & succeeds int_list(?l2) => 
    succeeds permutation(?l1 ** ?l2,?l3),
   succeeds int_list(?l1) & succeeds int_list(?l2) => 
    succeeds permutation(?l1 ** ?l2,?l3),
   succeeds permutation(?l1 ** ?l2,?l3)],
  succeeds permutation(?l1 ** ?l2,?l3))]
).

:- theorem(mergesort:permutation,
all [l1,l2]: succeeds mergesort(?l1,?l2) & succeeds int_list(?l1) =>
  succeeds permutation(?l1,?l2),
[induction(
  [all [l1,l2]: succeeds mergesort(?l1,?l2) => succeeds int_list(?l1) => 
      succeeds permutation(?l1,?l2)],
  [step([],[],[],succeeds int_list([]) => succeeds permutation([],[])),
   step([x],
    [],
    assume(succeeds int_list([?x]),
     succeeds permutation([?x],[?x]) by theorem(permutation:reflexive),
     succeeds permutation([?x],[?x])),
    succeeds int_list([?x]) => succeeds permutation([?x],[?x])),
   step([x,y,xs,ys,xs1,xs2,ys1,ys2],
    [succeeds int_list(?xs1) => succeeds permutation(?xs1,?ys1),
     succeeds int_list(?xs2) => succeeds permutation(?xs2,?ys2),
     succeeds split([?x,?y|?xs],?xs1,?xs2),
     succeeds mergesort(?xs1,?ys1),
     succeeds mergesort(?xs2,?ys2),
     succeeds merge(?ys1,?ys2,?ys)],
    assume(succeeds int_list([?x,?y|?xs]),
     [succeeds int_list(?xs1) & succeeds int_list(?xs2) by lemma(split:types:2),
      succeeds permutation(?xs1,?ys1),
      succeeds permutation(?xs2,?ys2),
      succeeds permutation([?x,?y|?xs],?xs1 ** ?xs2) by lemma(split:permutation),
      succeeds permutation(?xs1 ** ?xs2,?ys1 ** ?ys2) by theorem(permutation:app),
      succeeds permutation([?x,?y|?xs],?ys1 ** ?ys2) by theorem(permutation:transitive),
      succeeds int_list(?ys1) by lemma(mergesort:types),
      succeeds int_list(?ys2) by lemma(mergesort:types),
      succeeds permutation(?ys1 ** ?ys2,?ys) by lemma(merge:permutation),
      succeeds permutation([?x,?y|?xs],?ys) by theorem(permutation:transitive)],
     succeeds permutation([?x,?y|?xs],?ys)),
    succeeds int_list([?x,?y|?xs]) => succeeds permutation([?x,?y|?xs],?ys))]),
 assume(succeeds mergesort(?l1,?l2) & succeeds int_list(?l1),
  [succeeds int_list(?l1) => succeeds permutation(?l1,?l2),
   succeeds int_list(?l1) => succeeds permutation(?l1,?l2),
   succeeds permutation(?l1,?l2)],
  succeeds permutation(?l1,?l2))]
).

:- lemma(merge:first:element,
all [x,xs,y,ys,l]: succeeds merge([?x|?xs],[?y|?ys],?l) =>
  (ex zs: ?l = [?x|?zs] \/ ?l = [?y|?zs]),
assume(succeeds merge([?x|?xs],[?y|?ys],?l),
 [def succeeds merge([?x|?xs],[?y|?ys],?l) by completion,
  exist([z,zs],
   ?l = [?z|?zs] &
   (succeeds ?x =< ?y & ?z = ?x & succeeds merge(?xs,[?y|?ys],?zs) \/
    fails ?x =< ?y & ?z = ?y & succeeds merge([?x|?xs],?ys,?zs)),
   cases(succeeds ?x =< ?y & ?z = ?x & succeeds merge(?xs,[?y|?ys],?zs),
    [?l = [?x|?zs],
     ?l = [?x|?zs] \/ ?l = [?y|?zs],
     ex zs: ?l = [?x|?zs] \/ ?l = [?y|?zs]],
    fails ?x =< ?y & ?z = ?y & succeeds merge([?x|?xs],?ys,?zs),
    [?l = [?y|?zs],
     ?l = [?x|?zs] \/ ?l = [?y|?zs],
     ex zs: ?l = [?x|?zs] \/ ?l = [?y|?zs]],
    ex zs: ?l = [?x|?zs] \/ ?l = [?y|?zs]),
   ex zs: ?l = [?x|?zs] \/ ?l = [?y|?zs])],
 ex zs: ?l = [?x|?zs] \/ ?l = [?y|?zs])
).

:- lemma(int_ordered:cons,
all [x,l]: succeeds int_ordered([?x|?l]) => succeeds int_ordered(?l),
assume(succeeds int_ordered([?x|?l]),
 [def succeeds int_ordered([?x|?l]) by completion,
  cases(?l = [],
   [],
   ex [y,1]: ?l = [?y|?1] & succeeds ?x =< ?y &
    succeeds int_ordered([?y|?1]),
   exist([y,1],
    ?l = [?y|?1] & succeeds ?x =< ?y & succeeds int_ordered([?y|?1]),
    [],
    succeeds int_ordered(?l)),
   succeeds int_ordered(?l))],
 succeeds int_ordered(?l))
).

:- lemma(merge:int_ordered,
all [l1,l2,l3]: succeeds merge(?l1,?l2,?l3) &
 succeeds int_list(?l1) & succeeds int_list(?l2) &
 succeeds int_ordered(?l1) & succeeds int_ordered(?l2) =>
  succeeds int_ordered(?l3),
[induction(
  [all [l1,l2,l3]: succeeds merge(?l1,?l2,?l3) => succeeds int_list(?l1) &
     succeeds int_list(?l2) & succeeds int_ordered(?l1) &
     succeeds int_ordered(?l2) => succeeds int_ordered(?l3)],
  [step([xs],
    [],
    assume(succeeds int_list([]) & succeeds int_list(?xs) &
     succeeds int_ordered([]) & succeeds int_ordered(?xs),
     [],
     succeeds int_ordered(?xs)),
    succeeds int_list([]) & succeeds int_list(?xs) &
    succeeds int_ordered([]) & succeeds int_ordered(?xs) => 
     succeeds int_ordered(?xs)),
   step([xs],
    [],
    assume(succeeds int_list(?xs) & succeeds int_list([]) &
     succeeds int_ordered(?xs) & succeeds int_ordered([]),
     [],
     succeeds int_ordered(?xs)),
    succeeds int_list(?xs) & succeeds int_list([]) &
    succeeds int_ordered(?xs) & succeeds int_ordered([]) => 
     succeeds int_ordered(?xs)),
   step([x,xs,y,ys,z,zs],
    [succeeds int_list(?xs) & succeeds int_list([?y|?ys]) &
     succeeds int_ordered(?xs) & succeeds int_ordered([?y|?ys]) => 
      succeeds int_ordered(?zs),
     succeeds ?x =< ?y,
     ?z = ?x,
     succeeds merge(?xs,[?y|?ys],?zs)],
    assume(succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) &
     succeeds int_ordered([?x|?xs]) & succeeds int_ordered([?y|?ys]),
     [def succeeds int_list([?x|?xs]) by completion,
      succeeds int_ordered(?xs) by lemma(int_ordered:cons),
      succeeds int_ordered(?zs),
      def succeeds int_list(?xs) by completion,
      cases(?xs = [],
       [def succeeds merge([],[?y|?ys],?zs) by completion,
	?zs = [?y|?ys],
	succeeds int_ordered([?x,?y|?ys]) by sld,
	succeeds int_ordered([?z|?zs])],
       ex [x,l]: ?xs = [?x|?l] & succeeds integer(?x) &
        succeeds int_list(?l),
       exist([0,l],
        ?xs = [?0|?l] & succeeds integer(?0) & succeeds int_list(?l),
        [succeeds merge([?0|?l],[?y|?ys],?zs),
	 ex l1: ?zs = [?0|?l1] \/ ?zs = [?y|?l1] by lemma(merge:first:element),
	 exist(l1,
          ?zs = [?0|?l1] \/ ?zs = [?y|?l1],
          cases(?zs = [?0|?l1],
           [def succeeds int_ordered([?x,?0|?l]) by completion,
	    succeeds int_ordered([?0|?l1]),
	    succeeds ?x =< ?0,
	    succeeds int_ordered([?x,?0|?l1]) by sld,
	    succeeds int_ordered([?z|?zs])],
           ?zs = [?y|?l1],
           [succeeds int_ordered([?y|?l1]),
	    succeeds int_ordered([?x,?y|?l1]) by sld,
	    succeeds int_ordered([?z|?zs])],
           succeeds int_ordered([?z|?zs])),
          succeeds int_ordered([?z|?zs]))],
        succeeds int_ordered([?z|?zs])),
       succeeds int_ordered([?z|?zs]))],
     succeeds int_ordered([?z|?zs])),
    succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) &
    succeeds int_ordered([?x|?xs]) & succeeds int_ordered([?y|?ys]) => 
     succeeds int_ordered([?z|?zs])),
   step([x,xs,y,ys,z,zs],
    [succeeds int_list([?x|?xs]) & succeeds int_list(?ys) &
     succeeds int_ordered([?x|?xs]) & succeeds int_ordered(?ys) => 
      succeeds int_ordered(?zs),
     fails ?x =< ?y,
     ?z = ?y,
     succeeds merge([?x|?xs],?ys,?zs)],
    assume(succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) &
     succeeds int_ordered([?x|?xs]) & succeeds int_ordered([?y|?ys]),
     [def succeeds int_list([?x|?xs]) by completion,
      def succeeds int_list([?y|?ys]) by completion,
      succeeds ?y =< ?x by axiom(leq:total),
      succeeds int_ordered(?ys) by lemma(int_ordered:cons),
      succeeds int_ordered(?zs),
      def succeeds int_list(?ys) by completion,
      cases(?ys = [],
       [def succeeds merge([?x|?xs],[],?zs) by completion,
	?zs = [?x|?xs],
	succeeds int_ordered([?y,?x|?xs]) by sld,
	succeeds int_ordered([?z|?zs])],
       ex [x,l]: ?ys = [?x|?l] & succeeds integer(?x) &
        succeeds int_list(?l),
       exist([0,l],
        ?ys = [?0|?l] & succeeds integer(?0) & succeeds int_list(?l),
        [succeeds merge([?x|?xs],[?0|?l],?zs),
	 ex l1: ?zs = [?x|?l1] \/ ?zs = [?0|?l1] by lemma(merge:first:element),
	 exist(l1,
          ?zs = [?x|?l1] \/ ?zs = [?0|?l1],
          cases(?zs = [?x|?l1],
           [succeeds int_ordered([?x|?l1]),
	    succeeds int_ordered([?y,?x|?l1]) by sld,
	    succeeds int_ordered([?z|?zs])],
           ?zs = [?0|?l1],
           [succeeds int_ordered([?0|?l1]),
	    def succeeds int_ordered([?y,?0|?l]) by completion,
	    succeeds ?y =< ?0,
	    succeeds int_ordered([?y,?0|?l1]) by sld,
	    succeeds int_ordered([?z|?zs])],
           succeeds int_ordered([?z|?zs])),
          succeeds int_ordered([?z|?zs]))],
        succeeds int_ordered([?z|?zs])),
       succeeds int_ordered([?z|?zs]))],
     succeeds int_ordered([?z|?zs])),
    succeeds int_list([?x|?xs]) & succeeds int_list([?y|?ys]) &
    succeeds int_ordered([?x|?xs]) & succeeds int_ordered([?y|?ys]) => 
     succeeds int_ordered([?z|?zs]))]),
 assume(succeeds merge(?l1,?l2,?l3) & succeeds int_list(?l1) &
  succeeds int_list(?l2) & succeeds int_ordered(?l1) &
  succeeds int_ordered(?l2),
  [succeeds int_list(?l1) & succeeds int_list(?l2) &
   succeeds int_ordered(?l1) & succeeds int_ordered(?l2) => 
    succeeds int_ordered(?l3),
   succeeds int_list(?l1) & succeeds int_list(?l2) &
   succeeds int_ordered(?l1) & succeeds int_ordered(?l2) => 
    succeeds int_ordered(?l3),
   succeeds int_ordered(?l3)],
  succeeds int_ordered(?l3))]
).

:- theorem(mergesort:int_ordered,
all [l1,l2]: succeeds mergesort(?l1,?l2) & succeeds int_list(?l1) =>
  succeeds int_ordered(?l2),
[induction(
  [all [l1,l2]: succeeds mergesort(?l1,?l2) => succeeds int_list(?l1) => 
      succeeds int_ordered(?l2)],
  [step([],[],[],succeeds int_list([]) => succeeds int_ordered([])),
   step([x],
    [],
    [],
    succeeds int_list([?x]) => succeeds int_ordered([?x])),
   step([x,y,xs,ys,xs1,xs2,ys1,ys2],
    [succeeds int_list(?xs1) => succeeds int_ordered(?ys1),
     succeeds int_list(?xs2) => succeeds int_ordered(?ys2),
     succeeds split([?x,?y|?xs],?xs1,?xs2),
     succeeds mergesort(?xs1,?ys1),
     succeeds mergesort(?xs2,?ys2),
     succeeds merge(?ys1,?ys2,?ys)],
    assume(succeeds int_list([?x,?y|?xs]),
     [succeeds int_list(?xs1) & succeeds int_list(?xs2) by lemma(split:types:2),
      succeeds int_ordered(?ys1),
      succeeds int_ordered(?ys2),
      succeeds int_list(?ys1) by lemma(mergesort:types),
      succeeds int_list(?ys2) by lemma(mergesort:types),
      succeeds int_ordered(?ys) by lemma(merge:int_ordered)],
     succeeds int_ordered(?ys)),
    succeeds int_list([?x,?y|?xs]) => succeeds int_ordered(?ys))]),
 assume(succeeds mergesort(?l1,?l2) & succeeds int_list(?l1),
  [succeeds int_list(?l1) => succeeds int_ordered(?l2),
   succeeds int_list(?l1) => succeeds int_ordered(?l2),
   succeeds int_ordered(?l2)],
  succeeds int_ordered(?l2))]
).

:- bye(mergesort).
